<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ontology Browser - panres_v2</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --background-color: #f8f9fa;
            --hover-color: #eaecef;
            --text-color: #333;
            --border-color: #ddd;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
        }
        
        header {
            grid-column: 1 / -1;
            padding: 20px;
            background-color: var(--primary-color);
            color: white;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        h1 {
            margin-bottom: 10px;
        }
        
        .search-container {
            margin-top: 15px;
        }
        
        #search {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            width: 100%;
            max-width: 400px;
            font-size: 16px;
        }
        
        .class-hierarchy {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            max-height: calc(100vh - 150px);
        }
        
        .class-details {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            max-height: calc(100vh - 150px);
        }
        
        ul.tree, ul.tree ul {
            list-style: none;
        }
        
        ul.tree li {
            padding: 5px 0;
        }
        
        ul.tree li span {
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        ul.tree li span:hover {
            background-color: var(--hover-color);
        }
        
        ul.tree li span.selected {
            background-color: var(--secondary-color);
            color: white;
        }
        
        .caret {
            cursor: pointer;
            user-select: none;
            margin-right: 5px;
        }
        
        .caret::before {
            content: "▶";
            color: var(--secondary-color);
            display: inline-block;
            font-size: 0.8em;
        }
        
        .caret-down::before {
            content: "▼";
        }
        
        .nested {
            display: none;
            padding-left: 20px;
        }
        
        .active {
            display: block;
        }
        
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--secondary-color);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .property-list {
            margin-top: 20px;
        }
        
        .property-group {
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
        }
        
        .property-group h4 {
            color: var(--secondary-color);
            margin-bottom: 8px;
        }
        
        .info-box {
            background-color: #e3f2fd;
            border-left: 4px solid var(--secondary-color);
            padding: 10px 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        
        .error-box {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 10px 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
        }

        /* Style for individuals in the tree */
        ul.tree li span.individual-node {
            font-style: italic;
            color: #555;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
            display: block; /* Make individuals take full width */
            margin-left: 20px; /* Indent individuals */
        }

        ul.tree li span.individual-node:hover {
            background-color: var(--hover-color);
        }

        ul.tree li span.individual-node.selected {
            background-color: #77aaff; /* Lighter blue for selected individual */
            color: white;
        }

        /* Adjust caret positioning if needed */
        ul.tree li {
            position: relative; /* Needed for absolute positioning of caret if used */
            padding: 3px 0; /* Adjust padding */
        }

        .caret {
            /* ... existing caret styles ... */
            position: absolute; /* Position caret relative to li */
            left: 0;
            top: 8px; /* Adjust vertical alignment */
        }

        ul.tree li > span:not(.caret) { /* Apply padding to class/individual names */
             margin-left: 15px; /* Space for caret */
             display: inline-block; /* Ensure padding is applied correctly */
        }

        /* Ensure nested lists are indented correctly */
        .nested {
            padding-left: 25px; /* Increase indent for nested lists */
        }

        /* Style for property values */
        .property-value {
            margin-left: 15px;
            word-break: break-all; /* Prevent long URIs/strings from breaking layout */
        }
        .property-value ul {
            list-style: disc;
            margin-left: 20px;
        }
        .property-value li {
            margin-bottom: 3px;
        }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>panres_v2 Ontology Browser</h1>
            <p>Explore the class hierarchy and details of the ontology</p>
            <div class="search-container">
                <input type="text" id="search" placeholder="Search classes or individuals...">
            </div>
        </header>
        
        <div class="class-hierarchy">
            <h2>Ontology Explorer</h2>
            <div id="hierarchy-container">
                <div class="loader"></div>
            </div>
        </div>
        
        <div class="class-details">
            <h2>Details</h2>
            <div id="details-container">
                <div class="info-box">
                    Select an item from the explorer to view its details.
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const hierarchyContainer = document.getElementById('hierarchy-container');
            const detailsContainer = document.getElementById('details-container');
            const searchInput = document.getElementById('search');
            
            // OWL Namespace URIs
            const OWL = {
                RDF: "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
                RDFS: "http://www.w3.org/2000/01/rdf-schema#",
                OWL: "http://www.w3.org/2002/07/owl#",
                XSD: "http://www.w3.org/2001/XMLSchema#"
            };
            
            // Store all classes, individuals, and their relationships
            let ontologyData = {
                allClasses: [],
                topClasses: [],
                subClassMap: {},
                classDetails: {},
                allIndividuals: [],
                individualDetails: {},
                classInstanceMap: {}
            };
            
            // Keep track of all known URIs and their types (class/individual) for linking
            let uriRegistry = {};
            
            // Load and parse the ontology file
            try {
                // Show file input
                hierarchyContainer.innerHTML = `
                    <div class="info-box">
                        <p>Please select the panres_v2.owl file:</p>
                        <input type="file" id="file-input" accept=".owl">
                    </div>
                `;
                
                // Set up file input handler
                document.getElementById('file-input').addEventListener('change', function(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const text = e.target.result;
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(text, 'application/xml');
                        
                        // Check for parsing errors
                        const parserError = xmlDoc.querySelector("parsererror");
                        if (parserError) {
                            console.error("XML Parsing Error:", parserError.textContent);
                            hierarchyContainer.innerHTML = `
                                <div class="error-box">
                                    <p>Error parsing OWL file. Check browser console for details.</p>
                                    <p>Content: ${parserError.textContent.substring(0, 200)}...</p>
                                </div>`;
                            return;
                        }
                        
                        // Parse ontology data
                        parseOntology(xmlDoc);
                        
                        // Render the class hierarchy (including individuals)
                        renderClassHierarchy();
                        
                        // Setup search functionality
                        setupSearch();
                    };
                    reader.readAsText(file);
                });
            } catch (error) {
                hierarchyContainer.innerHTML = `
                    <div class="error-box">
                        <p>Error loading ontology: ${error.message}</p>
                        <p>Make sure 'panres_v2.owl' is in the same directory as this HTML file.</p>
                    </div>
                `;
            }
            
            function parseOntology(xmlDoc) {
                ontologyData = { // Reset data
                    allClasses: [], topClasses: [], subClassMap: {}, classDetails: {},
                    allIndividuals: [], individualDetails: {}, classInstanceMap: {}
                };
                uriRegistry = {};

                // --- 1. Parse Classes ---
                const classElements = xmlDoc.querySelectorAll("owl\\:Class, Class");
                classElements.forEach(classElem => {
                    const about = classElem.getAttribute('rdf:about') || classElem.getAttribute('about');
                    if (!about || about.startsWith('http://www.w3.org/')) return; // Skip anonymous classes and built-ins initially

                    const label = getClassLabel(classElem, about);
                    const classObj = {
                        id: about,
                        name: getLocalName(about),
                        label: label,
                        description: getClassDescription(classElem),
                        properties: [], // Placeholder for potential future property parsing
                        superClasses: [],
                        subClasses: [],
                        instances: [] // Initialize instances array
                    };

                    // Get superclasses
                    const subClassOfElems = classElem.querySelectorAll(":scope > rdfs\\:subClassOf, :scope > subClassOf"); // Use :scope > to get direct children
                    subClassOfElems.forEach(subClassElem => {
                        const resource = subClassElem.getAttribute('rdf:resource') || subClassElem.getAttribute('resource');
                        if (resource && !resource.startsWith('http://www.w3.org/2002/07/owl#Thing')) { // Exclude owl:Thing for top-level calculation
                            classObj.superClasses.push(resource);
                            if (!ontologyData.subClassMap[resource]) {
                                ontologyData.subClassMap[resource] = [];
                            }
                            ontologyData.subClassMap[resource].push(about);
                        }
                        // TODO: Handle complex restrictions if needed based on structure.yaml
                    });

                    ontologyData.allClasses.push(classObj);
                    ontologyData.classDetails[about] = classObj;
                    uriRegistry[about] = { type: 'class', label: label };
                });

                // Determine top-level classes
                ontologyData.topClasses = ontologyData.allClasses
                    .filter(cls => cls.superClasses.length === 0)
                    .map(cls => cls.id);

                 // Add subclasses to each class object
                ontologyData.allClasses.forEach(cls => {
                    cls.subClasses = ontologyData.subClassMap[cls.id] || [];
                });

                // --- 2. Parse Individuals ---
                const individualElements = xmlDoc.querySelectorAll("owl\\:NamedIndividual, NamedIndividual");
                individualElements.forEach(indElem => {
                    const about = indElem.getAttribute('rdf:about') || indElem.getAttribute('about');
                    if (!about) return;

                    const label = getClassLabel(indElem, about); // Use same function for potential rdfs:label on individuals
                    const individualObj = {
                        id: about,
                        name: getLocalName(about),
                        label: label, // Often same as name if no label
                        description: getClassDescription(indElem), // Check for comments
                        types: [], // Classes this individual belongs to
                        properties: {} // Store property assertions { propUri: [{ type: 'uri'/'literal', value: '...', datatype: '...' }] }
                    };

                    // Get types (classes)
                    const typeElems = indElem.querySelectorAll(":scope > rdf\\:type, :scope > type");
                    typeElems.forEach(typeElem => {
                        const resource = typeElem.getAttribute('rdf:resource') || typeElem.getAttribute('resource');
                        if (resource && !resource.startsWith('http://www.w3.org/')) { // Ignore owl:NamedIndividual type itself
                            individualObj.types.push(resource);
                            // Link instance to class
                            if (!ontologyData.classInstanceMap[resource]) {
                                ontologyData.classInstanceMap[resource] = [];
                            }
                            ontologyData.classInstanceMap[resource].push(about);
                            // Also add to the class object if it exists
                            if (ontologyData.classDetails[resource]) {
                                ontologyData.classDetails[resource].instances.push(about);
                            }
                        }
                    });

                    // Get property assertions (direct children)
                    Array.from(indElem.children).forEach(child => {
                        const propUri = child.namespaceURI + child.localName; // Full property URI

                        // Skip rdf:type, rdfs:label, rdfs:comment which are handled separately
                        if (propUri === OWL.RDF + 'type' || propUri === OWL.RDFS + 'label' || propUri === OWL.RDFS + 'comment') {
                            return;
                        }

                        const resource = child.getAttribute('rdf:resource') || child.getAttribute('resource');
                        const datatype = child.getAttribute('rdf:datatype') || child.getAttribute('datatype');
                        const value = child.textContent.trim();

                        if (!individualObj.properties[propUri]) {
                            individualObj.properties[propUri] = [];
                        }

                        if (resource) {
                            // Object Property Assertion
                            individualObj.properties[propUri].push({ type: 'uri', value: resource });
                        } else {
                            // Data/Annotation Property Assertion
                            individualObj.properties[propUri].push({ type: 'literal', value: value, datatype: datatype });
                        }
                    });


                    ontologyData.allIndividuals.push(individualObj);
                    ontologyData.individualDetails[about] = individualObj;
                    uriRegistry[about] = { type: 'individual', label: label };
                });

                console.log("Parsed Ontology Data:", ontologyData);
                console.log("URI Registry:", uriRegistry);
            }
            
            function getLocalName(uri) {
                // Extract the local name from a URI (text after the last # or /)
                const hashIndex = uri.lastIndexOf('#');
                const slashIndex = uri.lastIndexOf('/');
                const index = Math.max(hashIndex, slashIndex);
                return index !== -1 ? uri.substring(index + 1) : uri;
            }
            
            function getClassLabel(classElem, fallbackUri) {
                // Try to get rdfs:label, fall back to local name
                const labelElems = classElem.querySelectorAll("rdfs\\:label, label");
                if (labelElems.length > 0) {
                    return labelElems[0].textContent.trim();
                }
                return getLocalName(fallbackUri);
            }
            
            function getClassDescription(classElem) {
                // Try to get rdfs:comment
                const commentElems = classElem.querySelectorAll("rdfs\\:comment, comment");
                if (commentElems.length > 0) {
                    return commentElems[0].textContent.trim();
                }
                return "";
            }
            
            function renderClassHierarchy() {
                hierarchyContainer.innerHTML = '';
                const treeUl = document.createElement('ul');
                treeUl.className = 'tree';

                const sortedTopClasses = ontologyData.topClasses
                    .map(id => ontologyData.classDetails[id])
                    .filter(Boolean) // Filter out potential undefined if ID wasn't found
                    .sort((a, b) => a.label.localeCompare(b.label))
                    .map(cls => cls.id);

                sortedTopClasses.forEach(classId => {
                    const classObj = ontologyData.classDetails[classId];
                    if (classObj) { // Ensure class object exists
                       const classItem = createClassTreeItem(classObj);
                       treeUl.appendChild(classItem);
                    }
                });

                hierarchyContainer.appendChild(treeUl);
                setupTreeToggles();
            }
            
            function createClassTreeItem(classObj) {
                const li = document.createElement('li');

                const hasSubClasses = classObj.subClasses && classObj.subClasses.length > 0;
                const hasInstances = classObj.instances && classObj.instances.length > 0;

                // Add caret if it has children (subclasses or instances)
                if (hasSubClasses || hasInstances) {
                    const caret = document.createElement('span');
                    caret.className = 'caret';
                    li.appendChild(caret);
                }

                // Create the class name element
                const classSpan = document.createElement('span');
                classSpan.textContent = classObj.label;
                classSpan.dataset.itemId = classObj.id; // Use generic itemId
                classSpan.dataset.itemType = 'class';
                classSpan.onclick = () => showClassDetails(classObj.id);
                li.appendChild(classSpan);


                // Create nested list if there are subclasses or instances
                if (hasSubClasses || hasInstances) {
                    const nestedUl = document.createElement('ul');
                    nestedUl.className = 'nested';

                    // Add subclasses first, sorted
                    if (hasSubClasses) {
                        const sortedSubClasses = classObj.subClasses
                            .map(id => ontologyData.classDetails[id])
                            .filter(Boolean) // Filter out undefined
                            .sort((a, b) => a.label.localeCompare(b.label))
                            .map(cls => cls.id);

                        sortedSubClasses.forEach(subClassId => {
                            const subClassObj = ontologyData.classDetails[subClassId];
                             if (subClassObj) { // Ensure subclass object exists
                                const subClassItem = createClassTreeItem(subClassObj); // Recursive call
                                nestedUl.appendChild(subClassItem);
                             }
                        });
                    }

                    // Add instances next, sorted
                    if (hasInstances) {
                         const sortedInstances = classObj.instances
                            .map(id => ontologyData.individualDetails[id])
                            .filter(Boolean) // Filter out undefined
                            .sort((a, b) => a.label.localeCompare(b.label));

                         sortedInstances.forEach(indObj => {
                             const instanceLi = document.createElement('li');
                             const instanceSpan = document.createElement('span');
                             instanceSpan.textContent = indObj.label;
                             instanceSpan.className = 'individual-node'; // Style individuals
                             instanceSpan.dataset.itemId = indObj.id;
                             instanceSpan.dataset.itemType = 'individual';
                             instanceSpan.onclick = () => showIndividualDetails(indObj.id);
                             instanceLi.appendChild(instanceSpan);
                             nestedUl.appendChild(instanceLi);
                         });
                    }

                    li.appendChild(nestedUl);
                }

                return li;
            }
            
            function setupTreeToggles() {
                // Set up toggling for tree carets
                const carets = document.querySelectorAll(".caret");
                carets.forEach(caret => {
                    caret.addEventListener("click", function() {
                        this.classList.toggle("caret-down");
                        const nestedList = this.parentElement.querySelector(".nested");
                        if (nestedList) {
                            nestedList.classList.toggle("active");
                        }
                    });
                });
            }
            
            function clearSelection() {
                 // Remove existing selected class/individual highlight
                const allSpans = document.querySelectorAll('ul.tree li span[data-item-id]');
                allSpans.forEach(span => span.classList.remove('selected'));
            }

            function highlightSelectedItem(itemId) {
                clearSelection();
                 // Add selected highlight
                const selectedSpan = document.querySelector(`span[data-item-id="${itemId}"]`);
                if (selectedSpan) {
                    selectedSpan.classList.add('selected');
                }
            }

            function renderUriLink(uri) {
                const info = uriRegistry[uri];
                if (info) {
                    // Known class or individual
                    return `<a href="#" title="${uri}" onclick="event.preventDefault(); document.querySelector('span[data-item-id=\\'${uri}\\']')?.click();">${info.label}</a>`;
                } else {
                    // Other URI (property, external link, etc.)
                    const label = getLocalName(uri);
                    return `<a href="${uri}" target="_blank" title="${uri}">${label}</a>`;
                }
            }

            function showClassDetails(classId) {
                const classObj = ontologyData.classDetails[classId];
                if (!classObj) {
                     detailsContainer.innerHTML = `<div class="error-box">Class details not found for ID: ${classId}</div>`;
                     return;
                }

                highlightSelectedItem(classId);

                let html = `
                    <h3>Class: ${classObj.label}</h3>
                    <p class="class-uri"><strong>URI:</strong> ${classObj.id}</p>
                `;

                if (classObj.description) {
                    html += `<div class="property-group">
                        <h4>Description</h4>
                        <p>${classObj.description}</p>
                    </div>`;
                }

                // Super classes
                if (classObj.superClasses && classObj.superClasses.length > 0) {
                    html += `<div class="property-group">
                        <h4>Parent Classes</h4>
                        <ul>`;
                    classObj.superClasses.forEach(superId => {
                        html += `<li>${renderUriLink(superId)}</li>`;
                    });
                    html += `</ul></div>`;
                }

                // Sub classes
                if (classObj.subClasses && classObj.subClasses.length > 0) {
                    html += `<div class="property-group">
                        <h4>Subclasses</h4>
                        <ul>`;
                    const sortedSubClasses = classObj.subClasses
                        .map(id => ontologyData.classDetails[id])
                        .filter(Boolean)
                        .sort((a, b) => a.label.localeCompare(b.label));
                    sortedSubClasses.forEach(subClass => {
                         html += `<li>${renderUriLink(subClass.id)}</li>`;
                    });
                    html += `</ul></div>`;
                }

                 // Instances
                if (classObj.instances && classObj.instances.length > 0) {
                    html += `<div class="property-group">
                        <h4>Instances (${classObj.instances.length})</h4>
                        <ul>`;
                    const sortedInstances = classObj.instances
                        .map(id => ontologyData.individualDetails[id])
                        .filter(Boolean)
                        .sort((a, b) => a.label.localeCompare(b.label));
                    sortedInstances.forEach(ind => {
                         html += `<li>${renderUriLink(ind.id)}</li>`;
                    });
                    html += `</ul></div>`;
                }


                detailsContainer.innerHTML = html;
            }

            // --- NEW Function: Show Individual Details ---
            function showIndividualDetails(individualId) {
                const indObj = ontologyData.individualDetails[individualId];
                 if (!indObj) {
                     detailsContainer.innerHTML = `<div class="error-box">Individual details not found for ID: ${individualId}</div>`;
                     return;
                 }

                highlightSelectedItem(individualId);

                let html = `
                    <h3>Individual: ${indObj.label}</h3>
                    <p class="class-uri"><strong>URI:</strong> ${indObj.id}</p>
                `;

                 if (indObj.description) {
                    html += `<div class="property-group">
                        <h4>Description</h4>
                        <p>${indObj.description}</p>
                    </div>`;
                }

                // Types (Classes)
                 if (indObj.types && indObj.types.length > 0) {
                    html += `<div class="property-group">
                        <h4>Types (Classes)</h4>
                        <ul>`;
                    indObj.types.forEach(typeId => {
                        html += `<li>${renderUriLink(typeId)}</li>`;
                    });
                    html += `</ul></div>`;
                }

                // Properties
                const properties = indObj.properties;
                if (Object.keys(properties).length > 0) {
                     html += `<div class="property-group"><h4>Properties</h4>`;

                     // Group properties by URI for display
                     Object.keys(properties).sort().forEach(propUri => {
                         const propLabel = getLocalName(propUri);
                         const values = properties[propUri]; // Array of {type, value, datatype}

                         html += `<div><strong>${renderUriLink(propUri)}:</strong>`; // Render property name as link

                         if (values.length > 1) { // Multiple values for this property
                             html += `<ul class="property-value">`;
                             values.forEach(val => {
                                 html += `<li>`;
                                 if (val.type === 'uri') {
                                     html += renderUriLink(val.value);
                                 } else {
                                     html += `${val.value}`;
                                     if (val.datatype) {
                                         html += ` <small>(${getLocalName(val.datatype)})</small>`;
                                     }
                                 }
                                 html += `</li>`;
                             });
                             html += `</ul>`;
                         } else if (values.length === 1) { // Single value
                             const val = values[0];
                             html += `<div class="property-value">`;
                             if (val.type === 'uri') {
                                 html += renderUriLink(val.value);
                             } else {
                                 html += `${val.value}`;
                                 if (val.datatype) {
                                     html += ` <small>(${getLocalName(val.datatype)})</small>`;
                                 }
                             }
                             html += `</div>`;
                         }
                         html += `</div>`; // Close property div
                     });

                     html += `</div>`; // Close property-group
                } else {
                     html += `<div class="info-box">No properties defined for this individual.</div>`;
                }


                detailsContainer.innerHTML = html;
            }

            function setupSearch() {
                searchInput.addEventListener('input', debounce(function() {
                    const searchTerm = this.value.toLowerCase().trim();
                    const allListItems = document.querySelectorAll('ul.tree li');
                    const allSpans = document.querySelectorAll('ul.tree li span[data-item-id]');

                    if (searchTerm.length < 2) {
                        // Reset view: show all, collapse all except top level
                        allListItems.forEach(li => {
                            li.style.display = ''; // Show item
                            const nestedList = li.querySelector(':scope > .nested');
                            const caret = li.querySelector(':scope > .caret');
                            if (nestedList) {
                                // Collapse if it's not a direct child of the main tree
                                if (li.parentElement !== hierarchyContainer.querySelector('ul.tree')) {
                                    nestedList.classList.remove('active');
                                    if(caret) caret.classList.remove('caret-down');
                                } else {
                                     nestedList.classList.add('active'); // Keep top level expanded? Or remove this line too.
                                     if(caret) caret.classList.add('caret-down');
                                }
                            }
                        });
                        return;
                    }

                    // Hide all items initially
                    allListItems.forEach(li => {
                        li.style.display = 'none';
                    });

                    // Find and show matching items and their ancestors
                    allSpans.forEach(span => {
                        const itemId = span.dataset.itemId;
                        const itemType = span.dataset.itemType;
                        let itemData;

                        if (itemType === 'class' && ontologyData.classDetails[itemId]) {
                            itemData = ontologyData.classDetails[itemId];
                        } else if (itemType === 'individual' && ontologyData.individualDetails[itemId]) {
                            itemData = ontologyData.individualDetails[itemId];
                        }

                        if (itemData) {
                            const label = itemData.label.toLowerCase();
                            const name = itemData.name.toLowerCase(); // Local name/ID
                            const desc = itemData.description?.toLowerCase() || '';

                            if (label.includes(searchTerm) || name.includes(searchTerm) || desc.includes(searchTerm)) {
                                // Show this item and its path to the root
                                let currentLi = span.closest('li');
                                while (currentLi) {
                                    currentLi.style.display = ''; // Show the list item

                                    // Expand parent lists and turn down carets
                                    const parentUl = currentLi.parentElement;
                                    if (parentUl && parentUl.classList.contains('nested')) {
                                        parentUl.classList.add('active');
                                        const parentLi = parentUl.closest('li');
                                        if (parentLi) {
                                            const parentCaret = parentLi.querySelector(':scope > .caret');
                                            if (parentCaret) {
                                                parentCaret.classList.add('caret-down');
                                            }
                                        }
                                    }
                                    // Move up to the parent list item
                                    currentLi = parentUl.closest('li');
                                }
                            }
                        }
                    });
                }, 300));
            }
            
            // Utility function for debouncing
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func.apply(this, args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
        });
    </script>
</body>
</html>
